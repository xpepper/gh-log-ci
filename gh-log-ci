#!/usr/bin/env bash

set -euo pipefail

PROGRAM="gh log-ci"
VERSION="0.4.1"

show_help() {
  cat <<'EOF'
gh log-ci - show CI status next to recent commits

Usage:
  gh log-ci [options] [<branch>]

Options:
  --branch <name>        Branch to inspect (alternative to positional <branch>)
  --limit, -n <n>        Number of commits to display (default: 15; env LOG_CI_LIMIT overrides)
  --concurrency, -c <n>  Max parallel API calls (default: 4; env LOG_CI_CONCURRENCY overrides)
  --checks, -C           Show per-check run summaries beneath each commit (env LOG_CI_SHOW_CHECKS=1)
  --no-spinner           Disable loading spinner (env LOG_CI_NO_SPINNER=1)
  --api-timeout <secs>   Max seconds per API request (default: 30; env LOG_CI_API_TIMEOUT)
  --watch                Continuously poll and update commit statuses
  --watch-interval <s>   Seconds between polls in watch mode (default: 10; env LOG_CI_WATCH_INTERVAL)
  --help, -h             Show this help text
  --version              Show version

Branch auto-detect order when <branch> not supplied:
  1. GitHub default branch (via gh repo view)
  2. master (if exists)
  3. main (if exists)
  4. current HEAD branch

Examples:
  gh log-ci                                  # auto-detect branch
  gh log-ci main                             # explicit positional branch
  gh log-ci --branch develop --limit 30
  gh log-ci -c 8 -n 50                       # increase parallelism and number of commits
  LOG_CI_SHOW_CHECKS=1 gh log-ci -n 10       # show per-check summaries (env)
  gh log-ci -C --limit 5                     # show per-check summaries (flag)
  gh log-ci --watch                          # watch mode (poll every 10s)
  gh log-ci --watch --watch-interval 30      # watch mode with custom interval

Additional environment:
  LOG_CI_WATCH_INTERVAL   Override default poll interval (10)
  LOG_CI_WATCH_ONCE=1     Internal/testing: run only one watch iteration then exit

Exit codes:
  0 success
  1 setup or API error

EOF
}

# Default values (can be overridden by env or flags)
USER_BRANCH=""
LIMIT="${LOG_CI_LIMIT:-15}"
CONCURRENCY="${LOG_CI_CONCURRENCY:-4}"
SHOW_CHECKS="${LOG_CI_SHOW_CHECKS:-0}"
NO_SPINNER="${LOG_CI_NO_SPINNER:-0}"
API_TIMEOUT="${LOG_CI_API_TIMEOUT:-30}"
WATCH=0
WATCH_INTERVAL="${LOG_CI_WATCH_INTERVAL:-10}"
CACHE_TTL="${LOG_CI_CACHE_TTL:-300}" # seconds (default 5 min)
CACHE_DIR="${LOG_CI_CACHE_DIR:-$HOME/.cache/gh-log-ci}"
CACHE_FILE="$CACHE_DIR/${OWNER:-unknown}_${REPO:-unknown}_success.cache"
CACHE_DEBUG="${LOG_CI_CACHE_DEBUG:-0}"

# Parse flags
POS_ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --branch)
      USER_BRANCH="${2:-}"; shift || true
      ;;
    --limit|-n)
      LIMIT="${2:-}"; shift || true
      ;;
    --concurrency|-c)
      CONCURRENCY="${2:-}"; shift || true
      ;;
    --checks|-C)
      SHOW_CHECKS=1
      ;;
    --no-spinner)
      NO_SPINNER=1
      ;;
    --api-timeout)
      API_TIMEOUT="${2:-}"; shift || true
      ;;
    --watch)
      WATCH=1
      ;;
    --watch-interval)
      WATCH_INTERVAL="${2:-}"; shift || true
      ;;
    -h|--help)
      show_help; exit 0
      ;;
    --version)
      echo "$PROGRAM $VERSION"; exit 0
      ;;
    --) # end of flags
      shift; break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      echo "Run with --help for usage." >&2
      exit 1
      ;;
    *)
      POS_ARGS+=("$1")
      ;;
  esac
  shift || true
done

# If positional branch provided and no --branch flag, use it.
if [[ -z "$USER_BRANCH" && ${#POS_ARGS[@]} -ge 1 ]]; then
  USER_BRANCH="${POS_ARGS[0]}"
fi

# Validate numeric inputs
if ! [[ "$LIMIT" =~ ^[0-9]+$ ]] || [[ "$LIMIT" -le 0 ]]; then
  echo "Error: --limit must be a positive integer (got '$LIMIT')." >&2
  exit 1
fi
if ! [[ "$CONCURRENCY" =~ ^[0-9]+$ ]] || [[ "$CONCURRENCY" -le 0 ]]; then
  echo "Error: --concurrency must be a positive integer (got '$CONCURRENCY')." >&2
  exit 1
fi
if ! [[ "$API_TIMEOUT" =~ ^[0-9]+$ ]] || [[ "$API_TIMEOUT" -le 0 ]]; then
  echo "Error: --api-timeout must be a positive integer (got '$API_TIMEOUT')." >&2
  exit 1
fi
if [[ "$WATCH" -eq 1 ]]; then
  if ! [[ "$WATCH_INTERVAL" =~ ^[0-9]+$ ]] || [[ "$WATCH_INTERVAL" -le 0 ]]; then
    echo "Error: --watch-interval must be a positive integer (got '$WATCH_INTERVAL')." >&2
    exit 1
  fi
fi

# Determine branch (BRANCH variable) using auto-detect if USER_BRANCH empty
if [[ -n "$USER_BRANCH" ]]; then
  BRANCH="$USER_BRANCH"
else
  GH_DEFAULT_BRANCH="$(gh repo view --json defaultBranchRef --jq .defaultBranchRef.name 2>/dev/null || true)"
  if [[ -n "${GH_DEFAULT_BRANCH}" ]]; then
    BRANCH="${GH_DEFAULT_BRANCH}"
  else
    if git show-ref --verify --quiet refs/heads/master || git ls-remote --exit-code origin master &>/dev/null; then
      BRANCH="master"
    elif git show-ref --verify --quiet refs/heads/main || git ls-remote --exit-code origin main &>/dev/null; then
      BRANCH="main"
    else
      BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo master)"
    fi
  fi
fi

# Detect remote URL for origin or fallback to first remote
REMOTE_URL=$(git remote get-url origin 2>/dev/null || git remote get-url "$(git remote | head -n1)" 2>/dev/null || true)
if [[ -z "${REMOTE_URL:-}" ]]; then
  echo "Error: Could not detect Git remote URL." >&2
  exit 1
fi

# Parse OWNER and REPO from GitHub remote URL (optional .git suffix)
if [[ "$REMOTE_URL" =~ github.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
  OWNER="${BASH_REMATCH[1]}"
  REPO="${BASH_REMATCH[2]}"
  REPO="${REPO%.git}"
else
  echo "Error: Remote URL is not a recognized GitHub URL." >&2
  exit 1
fi

# Ensure we have remote branch; fetch quietly, tolerate missing remote branch gracefully.
if git ls-remote --exit-code origin "$BRANCH" &>/dev/null; then
  git fetch origin "$BRANCH" --quiet
else
  echo "Warning: Remote branch '$BRANCH' not found on origin. Using local branch if available." >&2
fi

 # Build a format with: <plain SHA><TAB><colored pretty message>
# Use %x09 for a literal TAB (portable) so we can split safely.
FORMAT='%H%x09%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)<%an>%Creset'

run_with_timeout() {
  local _timeout="$1"; shift
  local _tmp_out
  _tmp_out="$(mktemp -t ghlogci_cmd.XXXX)"
  ("$@" > "$_tmp_out" 2>&1) &
  local _pid=$!
  local _elapsed=0
  while kill -0 "$_pid" 2>/dev/null; do
    if [[ $_elapsed -ge $_timeout ]]; then
      kill "$_pid" 2>/dev/null || true
      wait "$_pid" 2>/dev/null || true
      echo "__TIMEOUT__" > "$_tmp_out"
      break
    fi
    sleep 1
    _elapsed=$((_elapsed+1))
  done
  wait "$_pid" 2>/dev/null || true
  cat "$_tmp_out"
  rm -f "$_tmp_out" 2>/dev/null || true
}

run_once() {
  INDEX=0
  declare -A LINE_MAP
  declare -A SHA_MAP
  declare -A SUCCESS_CACHE
  while IFS=$'\t' read -r SHA MESSAGE; do
    LINE_MAP[$INDEX]="$MESSAGE"
    SHA_MAP[$INDEX]="$SHA"
    INDEX=$((INDEX+1))
  done < <(git log "origin/$BRANCH" --color=always --pretty="$FORMAT" -n "$LIMIT")

  # Prepare cache (success-only)
  if [[ ! -d "$CACHE_DIR" ]]; then
    mkdir -p "$CACHE_DIR" 2>/dev/null || true
  fi
  NOW_EPOCH=$(date +%s)
  if [[ -f "$CACHE_FILE" ]]; then
    while IFS=$'\t' read -r C_SHA C_TS; do
      if [[ -n "$C_SHA" && -n "$C_TS" ]]; then
        AGE=$((NOW_EPOCH - C_TS))
        if [[ $AGE -lt $CACHE_TTL ]]; then
          SUCCESS_CACHE[$C_SHA]="$C_TS"
        fi
      fi
    done < "$CACHE_FILE"
  fi

  TOTAL=$INDEX
  TMPDIR=$(mktemp -d 2>/dev/null || mktemp -d -t ghlogci)

  spinner() {
    local frames=('‚†ã' '‚†ô' '‚†π' '‚†∏' '‚†º' '‚†¥' '‚†¶' '‚†ß' '‚†á' '‚†è')
    local i=0
    while :; do
      if [[ -f "$TMPDIR/.done" ]]; then
        COMPLETED=$(wc -l < "$TMPDIR/.done" 2>/dev/null || echo 0)
      else
        COMPLETED=0
      fi
      printf "\r%s Fetching CI statuses... %d/%d" "${frames[$i]}" "$COMPLETED" "$TOTAL"
      i=$(((i+1)%${#frames[@]}))
      sleep 0.1
    done
  }

  trap '[[ -n "${SPINNER_PID:-}" ]] && kill "$SPINNER_PID" 2>/dev/null || true' INT TERM
  if [[ "$NO_SPINNER" -ne 1 ]]; then
    spinner &
    SPINNER_PID=$!
  fi

  pids=()
  for i in $(seq 0 $((TOTAL-1))); do
    SHA="${SHA_MAP[$i]}"
    # Cache hit: if commit is cached success and not showing checks, skip API
    if [[ -n "${SUCCESS_CACHE[$SHA]:-}" && "$SHOW_CHECKS" != "1" ]]; then
      if [[ "$CACHE_DEBUG" == "1" ]]; then
        echo "[cache hit] $SHA" >&2
      fi
      echo "‚úÖ  ${LINE_MAP[$i]}" > "$TMPDIR/$i"
      echo 1 >> "$TMPDIR/.done"
      continue
    fi
    (
      RAW_LINES=$(run_with_timeout "$API_TIMEOUT" gh api "/repos/$OWNER/$REPO/commits/$SHA/check-runs" --jq '.check_runs[] | [.name, (.status // ""), (.conclusion // "" )] | @tsv' 2>/dev/null || true)
      success_count=0; fail_count=0; cancel_count=0; pending_count=0; other_count=0; total_count=0
      DETAIL_OUTPUT=""
      if [[ -n "$RAW_LINES" && "$RAW_LINES" != "__TIMEOUT__" ]]; then
        while IFS=$'\t' read -r NAME STATUS CONCLUSION; do
          total_count=$((total_count+1))
          ICON_RUN=""
          if [[ -z "$CONCLUSION" && "$STATUS" != "completed" ]]; then
            ICON_RUN="üïì"; pending_count=$((pending_count+1))
          elif [[ "$CONCLUSION" == "success" ]]; then
            ICON_RUN="‚úÖ"; success_count=$((success_count+1))
          elif [[ "$CONCLUSION" =~ ^(failure|timed_out|action_required)$ ]]; then
            ICON_RUN="‚ùå"; fail_count=$((fail_count+1))
          elif [[ "$CONCLUSION" == "cancelled" ]]; then
            ICON_RUN="üö´"; cancel_count=$((cancel_count+1))
          elif [[ "$CONCLUSION" =~ ^(neutral|skipped|stale)$ ]]; then
            ICON_RUN="‚ûñ"; other_count=$((other_count+1))
          else
            ICON_RUN="‚ùî"; other_count=$((other_count+1))
          fi
          if [[ "$SHOW_CHECKS" == "1" ]]; then
            SHORT_NAME="$NAME"
            [[ ${#SHORT_NAME} -gt 40 ]] && SHORT_NAME="${SHORT_NAME:0:37}..."
            DETAIL_OUTPUT+="    ‚Ä¢ $ICON_RUN $SHORT_NAME ($STATUS${CONCLUSION:+/$CONCLUSION})\n"
          fi
        done <<<"$RAW_LINES"
      fi
      OVERALL_ICON="‚ùî"
      if [[ "$RAW_LINES" == "__TIMEOUT__" ]]; then
        OVERALL_ICON="‚è≤"
      fi
      if [[ $fail_count -gt 0 ]]; then
        OVERALL_ICON="‚ùå"
      elif [[ $pending_count -gt 0 ]]; then
        OVERALL_ICON="üïì"
      elif [[ $cancel_count -gt 0 ]]; then
        OVERALL_ICON="üö´"
      elif [[ $success_count -gt 0 && $fail_count -eq 0 ]]; then
        OVERALL_ICON="‚úÖ"
      fi
      {
        echo "$OVERALL_ICON  ${LINE_MAP[$i]}"
        if [[ "$SHOW_CHECKS" == "1" && -n "$DETAIL_OUTPUT" ]]; then
          printf "%b" "$DETAIL_OUTPUT"
        fi
      } > "$TMPDIR/$i"
      # Cache store: only add if overall success and not from timeout
      if [[ "$OVERALL_ICON" == "‚úÖ" && "$RAW_LINES" != "__TIMEOUT__" ]]; then
        # Append SHA and timestamp if not already present
        if [[ -z "${SUCCESS_CACHE[$SHA]:-}" ]]; then
          echo -e "$SHA\t$NOW_EPOCH" >> "$CACHE_FILE"
        fi
      fi
      echo 1 >> "$TMPDIR/.done"
    ) &
    pids+=($!)
    if [[ ${#pids[@]} -ge $CONCURRENCY ]]; then
      wait "${pids[0]}" 2>/dev/null || true
      pids=("${pids[@]:1}")
    fi
  done
  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done

  COMPLETED=$TOTAL
  if [[ -n "${SPINNER_PID:-}" && "$NO_SPINNER" -ne 1 ]]; then
    kill "$SPINNER_PID" 2>/dev/null || true
    wait "$SPINNER_PID" 2>/dev/null || true
    printf "\r%-60s\r" ""
  fi
  for i in $(seq 0 $((TOTAL-1))); do
    cat "$TMPDIR/$i" 2>/dev/null || echo "‚ùî  ${LINE_MAP[$i]}"
  done
  rm -rf "$TMPDIR" 2>/dev/null || true
  echo
}

if [[ $WATCH -eq 1 ]]; then
  while :; do
    # Use clear with fallback to ANSI reset; suppress errors (CI may lack termcap)
    clear 2>/dev/null || printf '\033c'
    echo "[watch] $(date '+%Y-%m-%d %H:%M:%S') branch=$BRANCH interval=${WATCH_INTERVAL}s limit=$LIMIT"
    run_once
    if [[ "${LOG_CI_WATCH_ONCE:-0}" == "1" ]]; then
      break
    fi
    sleep "$WATCH_INTERVAL"
  done
else
  run_once
fi
