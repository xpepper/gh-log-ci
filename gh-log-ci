#!/usr/bin/env bash

set -euo pipefail

PROGRAM="gh log-ci"
VERSION="0.1.0"

show_help() {
  cat <<'EOF'
gh log-ci - show CI status next to recent commits

Usage:
  gh log-ci [options] [<branch>]

Options:
  --branch <name>   Branch to inspect (alternative to positional <branch>)
  --limit, -n <n>   Number of commits to display (default: 15; env LOG_CI_LIMIT overrides)
  --help, -h        Show this help text
  --version         Show version

Branch auto-detect order when <branch> not supplied:
  1. GitHub default branch (via gh repo view)
  2. master (if exists)
  3. main (if exists)
  4. current HEAD branch

Examples:
  gh log-ci                # auto-detect branch
  gh log-ci main           # explicit positional branch
  gh log-ci --branch develop --limit 30

Exit codes:
  0 success
  1 setup or API error

EOF
}

# Default values (can be overridden by env or flags)
USER_BRANCH=""
LIMIT="${LOG_CI_LIMIT:-15}"

# Parse flags
POS_ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --branch)
      USER_BRANCH="${2:-}"; shift || true
      ;;
    --limit|-n)
      LIMIT="${2:-}"; shift || true
      ;;
    -h|--help)
      show_help; exit 0
      ;;
    --version)
      echo "$PROGRAM $VERSION"; exit 0
      ;;
    --) # end of flags
      shift; break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      echo "Run with --help for usage." >&2
      exit 1
      ;;
    *)
      POS_ARGS+=("$1")
      ;;
  esac
  shift || true
done

# If positional branch provided and no --branch flag, use it.
if [[ -z "$USER_BRANCH" && ${#POS_ARGS[@]} -ge 1 ]]; then
  USER_BRANCH="${POS_ARGS[0]}"
fi

# Validate LIMIT is an integer >0
if ! [[ "$LIMIT" =~ ^[0-9]+$ ]] || [[ "$LIMIT" -le 0 ]]; then
  echo "Error: --limit must be a positive integer (got '$LIMIT')." >&2
  exit 1
fi

# Determine branch (BRANCH variable) using auto-detect if USER_BRANCH empty
if [[ -n "$USER_BRANCH" ]]; then
  BRANCH="$USER_BRANCH"
else
  GH_DEFAULT_BRANCH="$(gh repo view --json defaultBranchRef --jq .defaultBranchRef.name 2>/dev/null || true)"
  if [[ -n "${GH_DEFAULT_BRANCH}" ]]; then
    BRANCH="${GH_DEFAULT_BRANCH}"
  else
    if git show-ref --verify --quiet refs/heads/master || git ls-remote --exit-code origin master &>/dev/null; then
      BRANCH="master"
    elif git show-ref --verify --quiet refs/heads/main || git ls-remote --exit-code origin main &>/dev/null; then
      BRANCH="main"
    else
      BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo master)"
    fi
  fi
fi

# Detect remote URL for origin or fallback to first remote
REMOTE_URL=$(git remote get-url origin 2>/dev/null || git remote get-url "$(git remote | head -n1)" 2>/dev/null || true)
if [[ -z "${REMOTE_URL:-}" ]]; then
  echo "Error: Could not detect Git remote URL." >&2
  exit 1
fi

# Parse OWNER and REPO from GitHub remote URL (optional .git suffix)
if [[ "$REMOTE_URL" =~ github.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
  OWNER="${BASH_REMATCH[1]}"
  REPO="${BASH_REMATCH[2]}"
  REPO="${REPO%.git}"
else
  echo "Error: Remote URL is not a recognized GitHub URL." >&2
  exit 1
fi

# Ensure we have remote branch; fetch quietly, tolerate missing remote branch gracefully.
if git ls-remote --exit-code origin "$BRANCH" &>/dev/null; then
  git fetch origin "$BRANCH" --quiet
else
  echo "Warning: Remote branch '$BRANCH' not found on origin. Using local branch if available." >&2
fi

echo "$REPO"

# Build a format with: <plain SHA><TAB><colored pretty message>
# Use %x09 for a literal TAB (portable) so we can split safely.
FORMAT='%H%x09%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)<%an>%Creset'

echo
echo "Commit status for $OWNER/$REPO ($BRANCH):"
echo "-----------------------------------------"

git log "origin/$BRANCH" --color=always --pretty="$FORMAT" -n "$LIMIT" |
while IFS=$'\t' read -r SHA MESSAGE; do
  # Query GitHub check runs for this commit
  CHECK_CONCLUSIONS=$(gh api "/repos/$OWNER/$REPO/commits/$SHA/check-runs" --jq '.check_runs[].conclusion' 2>/dev/null || true)

  ICON="‚ùî"
  if [[ -z "$CHECK_CONCLUSIONS" ]]; then
    ICON="üïì"
  elif echo "$CHECK_CONCLUSIONS" | grep -qE 'failure|timed_out|action_required'; then
    ICON="‚ùå"
  elif echo "$CHECK_CONCLUSIONS" | grep -q 'cancelled'; then
    ICON="üö´"
  elif echo "$CHECK_CONCLUSIONS" | grep -q 'success'; then
    ICON="‚úÖ"
  else
    ICON="üïì"
  fi

  echo "$ICON  $MESSAGE"
done

echo
