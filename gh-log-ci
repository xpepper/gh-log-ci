#!/usr/bin/env bash

set -euo pipefail

PROGRAM="gh log-ci"
VERSION="0.3.0"

show_help() {
  cat <<'EOF'
gh log-ci - show CI status next to recent commits

Usage:
  gh log-ci [options] [<branch>]

Options:
  --branch <name>        Branch to inspect (alternative to positional <branch>)
  --limit, -n <n>        Number of commits to display (default: 15; env LOG_CI_LIMIT overrides)
  --concurrency, -c <n>  Max parallel API calls (default: 4; env LOG_CI_CONCURRENCY overrides)
  --checks, -C           Show per-check run summaries beneath each commit (env LOG_CI_SHOW_CHECKS=1)
  --help, -h             Show this help text
  --version              Show version

Branch auto-detect order when <branch> not supplied:
  1. GitHub default branch (via gh repo view)
  2. master (if exists)
  3. main (if exists)
  4. current HEAD branch

Examples:
  gh log-ci                                  # auto-detect branch
  gh log-ci main                             # explicit positional branch
  gh log-ci --branch develop --limit 30
  gh log-ci -c 8 -n 50                       # increase parallelism and number of commits
  LOG_CI_SHOW_CHECKS=1 gh log-ci -n 10       # show per-check summaries (env)
  gh log-ci -C --limit 5                     # show per-check summaries (flag)

Exit codes:
  0 success
  1 setup or API error

EOF
}

# Default values (can be overridden by env or flags)
USER_BRANCH=""
LIMIT="${LOG_CI_LIMIT:-15}"
CONCURRENCY="${LOG_CI_CONCURRENCY:-4}"
SHOW_CHECKS="${LOG_CI_SHOW_CHECKS:-0}"

# Parse flags
POS_ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --branch)
      USER_BRANCH="${2:-}"; shift || true
      ;;
    --limit|-n)
      LIMIT="${2:-}"; shift || true
      ;;
    --concurrency|-c)
      CONCURRENCY="${2:-}"; shift || true
      ;;
    --checks|-C)
      SHOW_CHECKS=1
      ;;
    -h|--help)
      show_help; exit 0
      ;;
    --version)
      echo "$PROGRAM $VERSION"; exit 0
      ;;
    --) # end of flags
      shift; break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      echo "Run with --help for usage." >&2
      exit 1
      ;;
    *)
      POS_ARGS+=("$1")
      ;;
  esac
  shift || true
done

# If positional branch provided and no --branch flag, use it.
if [[ -z "$USER_BRANCH" && ${#POS_ARGS[@]} -ge 1 ]]; then
  USER_BRANCH="${POS_ARGS[0]}"
fi

# Validate numeric inputs
if ! [[ "$LIMIT" =~ ^[0-9]+$ ]] || [[ "$LIMIT" -le 0 ]]; then
  echo "Error: --limit must be a positive integer (got '$LIMIT')." >&2
  exit 1
fi
if ! [[ "$CONCURRENCY" =~ ^[0-9]+$ ]] || [[ "$CONCURRENCY" -le 0 ]]; then
  echo "Error: --concurrency must be a positive integer (got '$CONCURRENCY')." >&2
  exit 1
fi

# Determine branch (BRANCH variable) using auto-detect if USER_BRANCH empty
if [[ -n "$USER_BRANCH" ]]; then
  BRANCH="$USER_BRANCH"
else
  GH_DEFAULT_BRANCH="$(gh repo view --json defaultBranchRef --jq .defaultBranchRef.name 2>/dev/null || true)"
  if [[ -n "${GH_DEFAULT_BRANCH}" ]]; then
    BRANCH="${GH_DEFAULT_BRANCH}"
  else
    if git show-ref --verify --quiet refs/heads/master || git ls-remote --exit-code origin master &>/dev/null; then
      BRANCH="master"
    elif git show-ref --verify --quiet refs/heads/main || git ls-remote --exit-code origin main &>/dev/null; then
      BRANCH="main"
    else
      BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo master)"
    fi
  fi
fi

# Detect remote URL for origin or fallback to first remote
REMOTE_URL=$(git remote get-url origin 2>/dev/null || git remote get-url "$(git remote | head -n1)" 2>/dev/null || true)
if [[ -z "${REMOTE_URL:-}" ]]; then
  echo "Error: Could not detect Git remote URL." >&2
  exit 1
fi

# Parse OWNER and REPO from GitHub remote URL (optional .git suffix)
if [[ "$REMOTE_URL" =~ github.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
  OWNER="${BASH_REMATCH[1]}"
  REPO="${BASH_REMATCH[2]}"
  REPO="${REPO%.git}"
else
  echo "Error: Remote URL is not a recognized GitHub URL." >&2
  exit 1
fi

# Ensure we have remote branch; fetch quietly, tolerate missing remote branch gracefully.
if git ls-remote --exit-code origin "$BRANCH" &>/dev/null; then
  git fetch origin "$BRANCH" --quiet
else
  echo "Warning: Remote branch '$BRANCH' not found on origin. Using local branch if available." >&2
fi

echo "$REPO"

# Build a format with: <plain SHA><TAB><colored pretty message>
# Use %x09 for a literal TAB (portable) so we can split safely.
FORMAT='%H%x09%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)<%an>%Creset'

echo
echo "Commit status for $OWNER/$REPO ($BRANCH):"
echo "-----------------------------------------"

INDEX=0
declare -A LINE_MAP
declare -A SHA_MAP
while IFS=$'\t' read -r SHA MESSAGE; do
  LINE_MAP[$INDEX]="$MESSAGE"
  SHA_MAP[$INDEX]="$SHA"
  INDEX=$((INDEX+1))
done < <(git log "origin/$BRANCH" --color=always --pretty="$FORMAT" -n "$LIMIT")

TOTAL=$INDEX
TMPDIR=$(mktemp -d 2>/dev/null || mktemp -d -t ghlogci)
job_count=0
for i in $(seq 0 $((TOTAL-1))); do
  SHA="${SHA_MAP[$i]}"
  (
    # Fetch check runs with name, status, conclusion via gh built-in jq
    # status: queued|in_progress|completed
    # conclusion may be null until completed.
    RAW_LINES=$(gh api "/repos/$OWNER/$REPO/commits/$SHA/check-runs" --jq '.check_runs[] | [.name, (.status // ""), (.conclusion // "" )] | @tsv' 2>/dev/null || true)
    success_count=0; fail_count=0; cancel_count=0; pending_count=0; other_count=0; total_count=0
    DETAIL_OUTPUT=""
    if [[ -n "$RAW_LINES" ]]; then
      while IFS=$'\t' read -r NAME STATUS CONCLUSION; do
        total_count=$((total_count+1))
        ICON_RUN=""
        # Determine per-check icon
        if [[ -z "$CONCLUSION" && "$STATUS" != "completed" ]]; then
          ICON_RUN="üïì"; pending_count=$((pending_count+1))
        elif [[ "$CONCLUSION" == "success" ]]; then
          ICON_RUN="‚úÖ"; success_count=$((success_count+1))
        elif [[ "$CONCLUSION" =~ ^(failure|timed_out|action_required)$ ]]; then
          ICON_RUN="‚ùå"; fail_count=$((fail_count+1))
        elif [[ "$CONCLUSION" == "cancelled" ]]; then
          ICON_RUN="üö´"; cancel_count=$((cancel_count+1))
        elif [[ "$CONCLUSION" =~ ^(neutral|skipped|stale)$ ]]; then
          ICON_RUN="‚ûñ"; other_count=$((other_count+1))
        else
          ICON_RUN="‚ùî"; other_count=$((other_count+1))
        fi
        if [[ "$SHOW_CHECKS" == "1" ]]; then
          # Trim overly long names
          SHORT_NAME="$NAME"
          [[ ${#SHORT_NAME} -gt 40 ]] && SHORT_NAME="${SHORT_NAME:0:37}..."
          DETAIL_OUTPUT+="    ‚Ä¢ $ICON_RUN $SHORT_NAME ($STATUS${CONCLUSION:+/$CONCLUSION})\n"
        fi
      done <<<"$RAW_LINES"
    fi

    # Overall icon aggregation precedence
    OVERALL_ICON="‚ùî"
    if [[ $fail_count -gt 0 ]]; then
      OVERALL_ICON="‚ùå"
    elif [[ $pending_count -gt 0 && $fail_count -eq 0 ]]; then
      OVERALL_ICON="üïì"
    elif [[ $cancel_count -gt 0 && $success_count -eq 0 && $fail_count -eq 0 && $pending_count -eq 0 ]]; then
      OVERALL_ICON="üö´"
    elif [[ $success_count -gt 0 && $fail_count -eq 0 && $pending_count -eq 0 ]]; then
      OVERALL_ICON="‚úÖ"
    elif [[ $success_count -gt 0 && $fail_count -gt 0 ]]; then
      OVERALL_ICON="‚ö†"  # mixed
    fi

    {
      echo "$OVERALL_ICON  ${LINE_MAP[$i]}"
      if [[ "$SHOW_CHECKS" == "1" && -n "$DETAIL_OUTPUT" ]]; then
        printf "%b" "$DETAIL_OUTPUT"
      fi
    } > "$TMPDIR/$i"
  ) &
  job_count=$((job_count+1))
  if [[ $job_count -ge $CONCURRENCY ]]; then
    wait -n || wait
    job_count=$((job_count-1))
  fi
done
wait

for i in $(seq 0 $((TOTAL-1))); do
  cat "$TMPDIR/$i" 2>/dev/null || echo "‚ùî  ${LINE_MAP[$i]}"
done
rm -rf "$TMPDIR" 2>/dev/null || true

echo
